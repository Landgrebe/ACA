\section{Design}


\subsection{Kontinuer controller design}
\subsubsection{Systemidentification}

For at kunne estimere dette system, er det første som skulle laves en overføringsfunktion, for den motor samt vippemekanisme som blev brugt til projektet. Her stødte vi på det første problem med systemet, da det ikke var stabilt. Vi blev derfor nød til at indsætte en form for fjedre, for at sikre at systemet var stabilt i en stationær position. Hertil blev der valgt at tilføje en elastik til hver side af bilen, for at opfylde ønsket om et stabilt stationær system. 
Herefter blev målingen lavet for at identificere, en overføringsfunktion for motoren. Da dette system, både skal kunne gå mod højre og venstre, blev der påført et firkantsignal. Herunder ses, hvordan responsen \textit{beta} fra motorens tachometer ser ud ved påførelse af firkantsignalet.      


\begin{figure}[H]
	\centering
	\includegraphics[width = 300pt]{figur/system_respons}
	\caption{System Respons}
	\label{fig:system_respons}
\end{figure}


Overføringsfunktionen bliver genereret ud fra funktionen \textit{tfest()}, som estimerer en overføring ud fra inputtet vs outputtet \textit{beta}. Hertil får vi overføringsfunktionen:

\begin{equation}
Tf(s) = \frac{188.6}{s^2 + 188.6 s + 358.2}
\end{equation}
    

\subsubsection{Pol placeringskontrol}
For at opfylde vores krav til dynamikken, forsøges der at placeres dominerede poler i systemet. Først findes damping ratio'en ($ \zeta $) ud fra valget om overshoot (OS) på følgende måde: 

\begin{equation}
\zeta = \frac{-\ln(OS/100)}{\sqrt{\pi^2+\ln^2(OS/100)}}
\end{equation} 

Dernæst findes båndbredden wn ud fra $ \zeta $ og valget om settling time (Ts) på følgede måde:

\begin{equation}
wn = \frac{4}{\zeta*Ts}
\end{equation} 

Til sidst kan den ønskede karakteristiske ligning (Gs) findes og ved:
\begin{equation}
G(s) = \frac{wn^2}{s^2+2*\zeta*wn*s+wn^2}
\end{equation}

Ud fra G(s) findes isoleres polerne, som skal bruges til at opfylde kravene om settling time (Ts) og overshoot (OS). For vores krav ligger polerne  derfor i -4\textpm\ 4.08i. For at fjerne steady state error tilføjes en ekstra pol i 5-10 gange real delen af de dominerende poler. Denne ekstra pol på reel aksen fungere som integrator i kontrolloopet, som korrigerer steady state error'en, men den øger også ordenen af systemet.


\subsubsection{State space model}

I dette projekt bliver systemet controller del repræsenteret på controller state space form, dette gøres for at kunne ændre på state vectorerne, som ændres vha. gainblokke (K), som bliver tilføjet til systemet. For at transformere transferfunktionen til en state space model, laves en state space tranformation i matlab. State space formlen giver følgende state space repræsentation

\begin{enumerate}
	
	\item
	$
	A = 
	\begin{bmatrix}
	
	-24.6783 &-358.2121\\
	1.0000      &   0
	\end{bmatrix}
	$
	\item
	$
	B = 
	\begin{bmatrix}
	
	1\\
	0
	\end{bmatrix}
	$    
	
	\item 
	$
	C = 
	\begin{bmatrix}
	
	0  & 188.6101
	\end{bmatrix}
	$    
	\item
	$
	D = 
	\begin{bmatrix}
	
	0  
	\end{bmatrix}
	$  
\end{enumerate}      
Som vist tidligere, er der fundet nogle poler, som ønskes realiseret. Derfor indsættes en K matrix, som skal placeres, i tilbagekoblingen for at opnå de ønskede poler i close-loopet. Først forsøges blot de to konjugerede poler realiseret for at se om kravene til dynamikken er opfyldt, det gøres således:

\begin{lstlisting}[frame=single]
K = place(A,B,poles);
AA = A-B*(K);
sys=ss(AA,B,C,D);
\end{lstlisting}
Her er AA den nye state matrix som står for tilbagekoblingen med K værdierne for at placere de nye poler i Matlab. Resultatet af den tilbagekoblingen kan ses herunder. 

\begin{figure}[H]
	\centering
	\includegraphics[width = 1\textwidth]{figur/Step_continues_1}
	\caption{Step respons (StepAmplitude = 30) af Kontinuer controller uden steady state error korrektion}
	\label{fig:Kontinuer controller 1}
\end{figure}


Som det kan ses i \autoref{fig:Kontinuer controller 1}, passer dynamikken meget til kravene omkring overhoot og settling time men idet forstærkningen i systemet er for høj, kommer der  betydelig steady state error. Dette kan rettes til ved at tilføje den sidste pol som fjerner fejlen. Men først skal A og B matricen udvides så de kan indeholde den extra state, Dernæst skal alle tre poler placeres igen for at få tre nye K værdier, hvor den sidste er Ke, som ganges på integration polen i loopet. Dette kan ses herunder

\begin{lstlisting}[frame=single]
% Find feedback gains for the desired poles
A_new=[A [0;0];-C 0]; % A matrix after adding an extra state
B_new=[B;0]; % B matrix after adding an extra stat

k = place(A_new,B_new,pp);
K=[k(1) k(2)];
Ke=-k(3);

% Define closed loop system
A_CL=[A-B*K B*Ke;-C 0];
B_CL=[0;0;1];
C_CL=[C 0];
sys_CL=ss(A_CL,B_CL,C_CL,D);
\end{lstlisting}

Her er A\_CL den nye state matrix som står for den udvidede tilbagekoblingen med alle K værdierne for at placere polerne som ønsket i Matlab. Resultatet af den udvidede tilbagekoblingen kan ses herunder. 

\begin{figure}[H]
	\centering
	\includegraphics[width = 1\textwidth]{figur/Step_continues_2}
	\caption{Step respons (StepAmplitude = 30) af Kontinuer controller med steady state error korrektion}
	\label{fig:Kontinuer controller 2}
\end{figure}

Som det kan ses i \autoref{fig:Kontinuer controller 2}, passer responsen nu til både kravene omkring overhoot, settling time og steady state error.




\subsection{Observer design}
Da systemet i praksis foregår på en LEGO motorblok, kan vi ikke hente states matrixen direkte, da x1 og x2 er en del  af systemet, ift ligningen for state space controller repræsentationen: 
\begin{gather}
\dot{x}=Ax+Bu \\
y=Cx
\end{gather}
Derfor indsættes yderligere en blok i systemet, for at kunne observere ind og output, og på baggrund af dem, og den beregnede state matrix, beregnes en estimeret xhat, som skal bruges til tilbagekoblingen, som erstatning for states matrixen \\
Observer formlen hedder:


\begin{gather}
\dot{\hat{x}}=A\hat{x}+Bu+L(y-\hat{y}) \\
\hat{y}=C\hat{x}
\end{gather}

Vha af mellemregninger, får vi formlen: 
\begin{gather}
\dot{\hat{x}}=(A+BK-LC)\hat{x}+Ly \\
u=K\hat{x}
\end{gather}

Som er den formlen vi bruger til at lave vores observer.\\
Først skal vi vælge observatørens forstærkning $ L $. Da vi ønsker at observerens dynamik skal være meget hurtigere end selve systemet, skal vi placere polerne mindst fem gange længere til venstre end systemets dominerende poler. Vi kan designe observerens forstærkning med følgende kommando uden at transformere vores state space respræsentation til observer canonical form

\begin{lstlisting}[frame=single]
%Valg af poler er polerne ganget med 5
poles_L = poles*5; 
%Beregning af L
L = place(A', C', poles_L)'; 
\end{lstlisting}

Derfor kan observatøren nu implementeres i Simulink og bruges til at hente state matricen ud fra outputtet fra gyroskopet. Dette beskrives senere under "Simulation"

\subsection{Diskret controller design}
For at kunne implementere systemet på en microcontroller - som på LEGO EV3, kan systemet med fordel transformeres til en diskret state space model. Dette kommer af at reguleringen skal foregå på et digitalt system, som sampler med en bestemt frekvens. Både overføringsfunktionen og state space repræsentationen bliver transformeret til diskrete værdier, det samme gøres ved vores poler, hvormed K værdierne ændres til de passende værdier. Alt dette gøres igennem matlab, hvor funktionen c2d bliver brugt.


